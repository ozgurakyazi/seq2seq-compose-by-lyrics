from music21 import *
import glob
import ipdb
import numpy as np
import spacy
import re
spacy_nlp = spacy.load('en')

def get_data_from_dir(dir, single_sents=True):
    all_lyrics = []
    all_notes = []
    for file in glob.glob(f"{dir}/*.mid"):
        print(f"Working on {file}")
        if single_sents:
            lyrics, notes = parse_single_sentences(file)
            if not lyrics or not notes:
                print(f"No lyrics in {file}")
            else:
                all_lyrics.extend(lyrics)
                all_notes.extend(notes)
        else:
            lyrics, notes = parse_whole_lyrics(file)
            if not lyrics or not notes:
                print(f"No lyrics in {file}")
            else:
                all_lyrics.append(lyrics)
                all_notes.append(notes)
    return all_lyrics, all_notes

def get_notes_from_stream(s):
    notes = []
    notes_to_parse = s.flat.notes
    for element in notes_to_parse:
        if isinstance(element, note.Note):
            notes.append(str(element.pitch))
        elif isinstance(element, chord.Chord):
            notes.append('.'.join(str(n) for n in element.normalOrder))
    return notes

def parse_whole_lyrics(file, all_instruments=False):
    m = midi.MidiFile()
    m.open(file)
    m.read()
    for track in m.tracks:
        lyrics = [ev.data for ev in track.events if ev.type=="LYRIC"]
        if not all_instruments:
            temp_stream = midi.translate.midiTrackToStream(track)
            notes = get_notes_from_stream(temp_stream)
        if len(lyrics) > 0:
            break
    if all_instruments:
        song = converter.parse(file)
        notes = []
        notes_to_parse = song.flat.notes
        for element in notes_to_parse:
            if isinstance(element, note.Note):
                notes.append(str(element.pitch))
            elif isinstance(element, chord.Chord):
                notes.append('.'.join(str(n) for n in element.normalOrder))

    return lyrics, notes

def clean_word(word):
    rmv = [",","."]
    for c in rmv:
        word = word.replace(c,"")
    return word

def parse_single_sentences(file):
    lyrics = []
    notes = []
    m = midi.MidiFile()
    m.open(file)
    m.read()
    for track in m.tracks:
        if "LYRIC" in [ev.type for ev in track.events]:
            start = midi.translate.getStartEvents()
            end = midi.translate.getEndEvents()
            current_events = []
            current_lyrics = []
            for ev in track.events:
                if ev.type == "LYRIC":
                    if ev.data == b"\r":
                        try:
                            temp_track = midi.MidiTrack(1)
                            temp_track.events = start+current_events+end
                            temp_stream = midi.translate.midiTrackToStream(temp_track)
                            current_notes = get_notes_from_stream(temp_stream)
                            if len(current_notes) <= 100 and len(current_notes) > 0:
                                lyrics.append(preprocessing_pipeline(current_lyrics))
                                notes.append(current_notes)
                            else:
                                print(f"Not adding {current_notes} and {current_lyrics}")
                            current_lyrics = []
                            current_events = []
                        except Exception as e:
                            print(e)
                            print(f"Could not add {current_lyrics}")
                            current_lyrics = []
                            current_events = []
                    else:
                        current_lyrics.append(ev.data)
                else:
                    current_events.append(ev)

    return lyrics, notes

def notes_to_midi(notes_list, output):
    offset = 0
    output_notes = []
    # create note and chord objects based on the values generated by the model
    for pattern in notes_list:
        # pattern is a chord
        if ('.' in pattern) or pattern.isdigit():
            notes_in_chord = pattern.split('.')
            notes = []
            for current_note in notes_in_chord:
                new_note = note.Note(int(current_note))
                new_note.storedInstrument = instrument.Piano()
                notes.append(new_note)
            new_chord = chord.Chord(notes)
            new_chord.offset = offset
            output_notes.append(new_chord)
        # pattern is a note
        else:
            new_note = note.Note(pattern)
            new_note.offset = offset
            new_note.storedInstrument = instrument.Piano()
            output_notes.append(new_note)
        # increase offset each iteration so that notes do not stack
        offset += 0.5
    midi_stream = stream.Stream(output_notes)
    midi_stream.write('midi', fp=f'output/{output}.mid')


def play_midi(midi_file):
    song = converter.parse(midi_file)
    song.show("midi")

def lookup(sent, vocab):
    return [vocab[i] for i in sent if i in vocab]


def produce_batch(inputs, max_sequence_length=None):
    sequence_lengths = [len(seq) for seq in inputs]
    batch_size = len(inputs)

    if max_sequence_length is None:
        max_sequence_length = max(sequence_lengths)

    inputs_batch_major = np.zeros(shape=[batch_size, max_sequence_length], dtype=np.int32) # == PAD

    for i, seq in enumerate(inputs):
        for j, element in enumerate(seq):
            inputs_batch_major[i, j] = element

    # [batch_size, max_time] -> [max_time, batch_size]
    inputs_time_major = inputs_batch_major.swapaxes(0, 1)

    return inputs_time_major, sequence_lengths

def preprocessing_pipeline(sentence, is_list=True):
    if is_list:
        data_string = "".join([decontracted(i.decode("utf-8").lower()) for i in sentence])
    else:
        data_string = decontracted(sentence.lower())
    data_tokens = [token.lemma_ if not (token.lemma_ == "-PRON-" or token.pos_=="PUNCT") else token.text for token in spacy_nlp(data_string)]
    return data_tokens

def decontracted(sentence):
    # PUNCT
    sentence = re.sub(r"\{", "", sentence)
    sentence = re.sub(r"\}", "", sentence)
    sentence = re.sub(r"\[", "", sentence)
    sentence = re.sub(r"\]", "", sentence)
    sentence = re.sub(r"\(", "", sentence)
    sentence = re.sub(r"\)", "", sentence)
    sentence = re.sub(r"_", " ", sentence)
    sentence = re.sub(r"\n", "", sentence)
    sentence = re.sub(r",", "", sentence)

    return sentence



def prepare_prediction(lyrics, batch_size, data_dict):
    mask = 0
    while not len(lyrics) % batch_size == 0:
        lyrics.append("<PAD>")
        mask += 1
    predict_input = [data_dict.transform_sentence(preprocessing_pipeline(i, False)) for i in lyrics]
    return predict_input, mask
